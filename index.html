<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>TAP-DASH — Mundo lateral INFINITO</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
	@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
	html,body{height:100%;margin:0;background:#060712;font-family:'Press Start 2P',Inter,Arial,Helvetica,sans-serif; -webkit-tap-highlight-color: transparent;}
	#gameContainer{width:100%;height:100vh;overflow:hidden;position:relative;}
	#uiTop{position:absolute;left:12px;top:12px;color:#fff;font-weight:700;text-shadow:0 2px 6px rgba(0,0,0,0.6)}
	#uiRight{position:absolute;right:12px;top:12px;color:#fff;font-weight:700;text-shadow:0 2px 6px rgba(0,0,0,0.6)}
	.overlay{
		position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.35);
		backdrop-filter: blur(2px);transition:opacity .18s,visibility .18s;
	}
	#restartOverlay{
		visibility:hidden;opacity:0;
	}
	#startOverlay{
		visibility:visible;opacity:1;
	}
	.box{background:linear-gradient(180deg,#0f1724,#09101a);padding:24px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.6);text-align:center;color:#fff;min-width: 280px;}
	.box h1{margin:0 0 16px;font-size:24px;color:#00d1ff;}
	.box h2{margin:0 0 8px;font-size:20px}
	.box p{margin:0 0 16px;color:#d1d5db;font-family:Inter,Arial,Helvetica,sans-serif;font-size: 14px; line-height: 1.5;}
	.box p strong { color: #fff; }
	.box button{padding:12px 20px;border-radius:10px;border:0;background:#00d1ff;color:#031226;font-weight:800;font-size:15px;cursor:pointer}
	.pixel-font{font-family:'Press Start 2P',cursive;text-transform:uppercase;letter-spacing:0.5px;}
	canvas { display:block; width:100%; height:100%; }
</style>
</head>
<body>
<div id="gameContainer"></div>

<div id="uiTop">Distancia: <span id="score">0 m</span></div>
<div id="uiRight"></div>

<div id="startOverlay" class="overlay">
	<div id="startBox" class="box">
		<h1 class="pixel-font">TAP DASH</h1>
		<p>Toca la pantalla para cambiar de dirección y esquivar las bolas.</p>
		<button id="btnStart" class="pixel-font">START</button>
	</div>
</div>

<div id="restartOverlay" class="overlay">
	<div id="restartBox" class="box">
		<h2 id="restartBoxTitle" class="pixel-font">¡Te chocaste!</h2>
		<p>Distancia: <strong id="finalScore">0</strong> m</p>
		<p style="margin-top:-8px;">Máximo: <strong id="highScore">0</strong> m</p>
		<button id="btnRestart" class="pixel-font">RESTART</button>
	</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
<script>
(() => {
	const W = Math.max(320, Math.min(900, window.innerWidth));
	const H = Math.max(480, window.innerHeight);

	const config = {
		type: Phaser.AUTO,
		parent: 'gameContainer',
		width: W,
		height: H,
		backgroundColor: 0x060712,
		physics: { default: 'arcade', arcade: { debug: false } },
		scene: { preload, create, update }
	};

	const game = new Phaser.Game(config);

	function preload() {
		this.load.image('ship', 'assets/nave.png');
		this.load.image('point', 'assets/punto.png');
	}

	function create() {
		const scene = this;
		scene.speedVertical = 240;
		scene.horizSpeed = 180;
		scene.spawnGap = 200;
		scene.spawnAhead = 2200;
		scene.spawnWidth = 2200;
		scene.baseDensity = 1;
		scene.dir = 1;
		scene.isGameOver = false;
		scene.gamePaused = true;
		scene.distance = 0;
		scene.nextSpawnY = null;

		const g = scene.add.graphics();
		g.fillStyle(0x10131a, 1); g.fillRect(0,0,10,44); g.generateTexture('marker', 10, 44); g.clear(); g.destroy();

		scene.shipDisplay = Math.round(Math.max(36, Math.min(96, scene.scale.width * 0.12)));
		scene.pointSmall = Math.round(Math.max(18, scene.shipDisplay * 0.35));
		scene.pointLarge = Math.round(Math.max(28, scene.shipDisplay * 0.6));
		const startX = 0;
		const startY = scene.scale.height * 0.75;
		scene.player = scene.physics.add.sprite(startX, startY, 'ship');
		scene.player.setDepth(5);
		scene.player.setOrigin(0.5,0.5);
		scene.player.setDisplaySize(scene.shipDisplay, scene.shipDisplay);
		scene.player.body.setAllowGravity(false);
		const shipRadius = Math.round((scene.player.displayWidth / 2) * 0.8);
		scene.player.body.setCircle(shipRadius, Math.round(scene.player.displayWidth/2 - shipRadius), Math.round(scene.player.displayHeight/2 - shipRadius));

		const WORLD_HALF = 1e7;
		scene.cameras.main.setBounds(-WORLD_HALF, -WORLD_HALF, WORLD_HALF*2, WORLD_HALF*2);
		scene.physics.world.setBounds(-WORLD_HALF, -WORLD_HALF, WORLD_HALF*2, WORLD_HALF*2, true, true, true, true);

		// obstacles as dynamic group but we'll make each obstacle static (no body movement) so collisions are accurate.
		scene.obstacles = scene.physics.add.group({ allowGravity: false });
		scene.markers = scene.add.group();
		scene.physics.add.overlap(scene.player, scene.obstacles, onHit, null, scene);
		scene.cameras.main.startFollow(scene.player, true, 0.12, 0.12);
		scene.input.on('pointerdown', (pointer) => { if (scene.isGameOver || scene.gamePaused) return; toggleDir(scene); }, scene);
		scene.input.keyboard.on('keydown-SPACE', () => { if (scene.isGameOver || scene.gamePaused) return; toggleDir(scene); }, scene);

		scene.nextSpawnY = scene.player.y - scene.spawnGap - 40;
		ensureSpawnAhead(scene);
		scene.scoreEl = document.getElementById('score');
		scene.startOverlay = document.getElementById('startOverlay');
		scene.btnStart = document.getElementById('btnStart');
		scene.restartOverlay = document.getElementById('restartOverlay');
		scene.finalScoreEl = document.getElementById('finalScore');
		scene.highScoreEl = document.getElementById('highScore');
		scene.restartBoxTitle = document.getElementById('restartBoxTitle');

		scene.btnStart.addEventListener('click', () => {
			scene.startGame();
		});
		document.getElementById('btnRestart').addEventListener('click', () => {
			document.getElementById('gameContainer').style.filter = '';
			scene.restartGame();
		});

		scene.cameras.main.centerOn(scene.player.x, scene.player.y);
		scene.physics.pause();
	}

	function toggleDir(scene) {
		scene.dir *= -1;
		const targetAngle = scene.dir === 1 ? Phaser.Math.DegToRad(30) : Phaser.Math.DegToRad(-30);
		scene.tweens.killTweensOf(scene.player);
		scene.tweens.add({
			targets: scene.player,
			rotation: targetAngle,
			duration: 120,
			ease: 'Cubic.easeOut'
		});
		scene.player.setTint(0x88fffb);
		scene.time.addEvent({ delay: 110, callback: () => scene.player.clearTint() });
	}

	function ensureSpawnAhead(scene) {
		const targetTopY = scene.player.y - scene.spawnAhead;
		while (scene.nextSpawnY > targetTopY) {
			if (scene.nextSpawnY <= scene.player.y - scene.spawnGap) {
				spawnBandAt(scene, scene.nextSpawnY);
			}
			const distToPlayer = scene.player.y - scene.nextSpawnY;
			let step;
			if (distToPlayer < 1000) step = Phaser.Math.Between(140, 260);
			else if (distToPlayer < 3000) step = Phaser.Math.Between(100, 180);
			else step = Phaser.Math.Between(70, 140);
			scene.nextSpawnY -= step;
			if (scene.nextSpawnY < -1e9) break;
		}
	}

	function spawnBandAt(scene, bandY) {
		const densityFactor = Phaser.Math.FloatBetween(0.4, 1.8);
		const maxPerBand = 6;
		const count = Phaser.Math.Between(1, Math.max(1, Math.round(maxPerBand * scene.baseDensity * densityFactor)));
		const halfW = Math.round(scene.spawnWidth / 2);
		const centerX = Math.round(scene.player.x);
		for (let i = 0; i < count; i++) {
			const minHorGap = Math.round(scene.shipDisplay * 0.8);
			let x = Phaser.Math.Between(centerX - halfW, centerX + halfW);
			const horDist = Math.abs(x - centerX);
			if (horDist < minHorGap) {
				x += (x < centerX) ? -minHorGap : minHorGap;
			}
			const jitterY = Phaser.Math.Between(0, 60);
			const y = bandY - jitterY;
			spawnObstacle(scene, x, y);
		}
		if (Phaser.Math.Between(0, 100) < 72) {
			const mx = Phaser.Math.Between(centerX - halfW + 20, centerX + halfW - 20);
			const my = bandY - Phaser.Math.Between(5, 50);
			spawnMarker(scene, mx, my);
		}
	}

	function spawnObstacle(scene, x, y) {
		const isTiny = Phaser.Math.Between(0, 100) < 60;
		const img = scene.obstacles.create(x, y, 'point');
		img.setDepth(3);
		const displaySize = isTiny ? scene.pointSmall : scene.pointLarge;
		img.setDisplaySize(displaySize, displaySize);
		// ensure physics body matches visual
		img.refreshBody();
		const radius = Math.round(displaySize * 0.45);
		img.body.setCircle(radius, Math.round(img.displayWidth/2 - radius), Math.round(img.displayHeight/2 - radius));
		img.setData('createdAt', scene.time.now);

		// Make obstacles static / non-moving (no tween). This fixes collision inconsistencies
		if (img.body) {
			try {
				// prefer using static body behavior: stop body movement and make immovable
				img.body.setAllowGravity(false);
				if (typeof img.body.setImmovable === 'function') img.body.setImmovable(true);
				// Ensure arcade won't try to move it
				img.body.moves = false;
				// safety: zero velocity if applicable
				if (typeof img.body.setVelocity === 'function') img.body.setVelocity(0, 0);
			} catch (e) {
				// ignore if body doesn't support something
			}
		}
		// no tween for obstacle position: balls stay static
	}

	function spawnMarker(scene, x, y) {
		const m = scene.add.image(x, y, 'marker').setAlpha(0.06).setDepth(0);
		scene.markers.add(m);
		// markers can be decorative / animated, keep as-is
		scene.tweens.add({
			targets: m,
			x: x + Phaser.Math.Between(-18, 18),
			duration: Phaser.Math.Between(2000, 3800),
			yoyo: true,
			repeat: -1,
			ease: 'Sine.easeInOut'
		});
	}

	function onHit(player, obstacle) {
		const scene = this;
		if (scene.isGameOver) return;
		scene.isGameOver = true;
		scene.physics.pause();
		scene.player.setTint(0xff6b6b);
		document.getElementById('gameContainer').style.filter = 'blur(6px) saturate(.9)';

		const currentScore = Math.max(0, Math.floor(scene.distance));
		const highScore = parseInt(localStorage.getItem('tapdash_highscore') || 0, 10);
		let newRecord = false;
		if (currentScore > highScore) {
			localStorage.setItem('tapdash_highscore', currentScore);
			newRecord = true;
		}

		scene.finalScoreEl.innerText = currentScore;
		scene.highScoreEl.innerText = newRecord ? currentScore : highScore;
		scene.restartBoxTitle.innerText = newRecord ? '¡NUEVO RÉCORD!' : '¡Te chocaste!';

		scene.restartOverlay.style.visibility = 'visible';
		scene.restartOverlay.style.opacity = '1';
	}

	function update(time, dt) {
		const scene = this;
		if (scene.isGameOver || scene.gamePaused) return;

		const vy = -scene.speedVertical * (dt / 1000);
		const vx = scene.dir * scene.horizSpeed * (dt / 1000);
		scene.player.x += vx;
		scene.player.y += vy;

		if (scene.startY === undefined) scene.startY = scene.player.y;
		scene.distance = Math.max(0, Math.floor(scene.startY - scene.player.y));
		scene.scoreEl.innerText = scene.distance + ' m';

		ensureSpawnAhead(scene);
		const camBottom = scene.cameras.main.worldView.y + scene.cameras.main.height;
		const removeBelow = camBottom + 800;
		const removeHoriz = Math.max(scene.spawnWidth * 1.5, 3000);
		scene.obstacles.children.each(function(o) {
			if (!o || !o.active) return;
			if (o.y > removeBelow || Math.abs(o.x - scene.player.x) > removeHoriz) {
				if (o.body) o.body.destroy();
				o.destroy();
			}
		}, scene);
		scene.markers.children.each(function(m) {
			if (!m || !m.active) return;
			if (m.y > removeBelow || Math.abs(m.x - scene.player.x) > removeHoriz) m.destroy();
		});

		const targetRot = 0.32 * scene.dir;
		scene.player.rotation = Phaser.Math.Linear(scene.player.rotation, targetRot, 0.08);
	}

	Phaser.Scene.prototype.startGame = function() {
		const s = this;
		s.startOverlay.style.opacity = '0';
		s.startOverlay.style.visibility = 'hidden';
		s.physics.resume();
		s.gamePaused = false;
	};

	Phaser.Scene.prototype.restartGame = function() {
		const s = this;
		s.restartOverlay.style.opacity = '0';
		s.restartOverlay.style.visibility = 'hidden';
		s.isGameOver = false;
		s.gamePaused = false;
		s.physics.resume();
		document.getElementById('gameContainer').style.filter = '';
		s.obstacles.children.each(function(o){ if (o.body) o.body.destroy(); o.destroy(); }, s);
		s.markers.children.each(function(m){ m.destroy(); }, s);
		s.player.x = 0;
		s.player.y = s.scale.height * 0.75;
		s.player.clearTint();
		s.player.rotation = 0;
		s.dir = 1;
		s.distance = 0;
		s.scoreEl.innerText = '0 m';
		s.nextSpawnY = s.player.y - s.spawnGap - 40;
		s.startY = s.player.y;
		ensureSpawnAhead(s);
		s.cameras.main.centerOn(s.player.x, s.player.y);
	};
})();
</script>
</body>
</html>